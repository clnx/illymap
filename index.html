<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta name="description" content="Illymap : Illyriad Map Smelter" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <script type="text/javascript" src="javascripts/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="javascripts/gl-matrix-1.3.5-min.js"></script>
    <script type="text/javascript" src="javascripts/main.js"></script>
    <script id="main_shader-fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D uMapSampler;
      uniform sampler2D uStarSampler;
      uniform sampler2D uTownsSampler;
      uniform sampler2D uOverlaySampler;

      uniform bool uGreyBg;
      uniform bool uStars;
      uniform vec3 uStarColor;
      uniform bool uShowTowns;
      uniform bool uShowBg;
      uniform bool uShowOverlay;

      varying vec2 vTextureCoord;

      void main(void) {
        if (uStars) {
          vec4 textureColor = texture2D(uStarSampler, vec2(vTextureCoord.s, vTextureCoord.t));
          gl_FragColor = textureColor * vec4(uStarColor, 1.0);
        }
        else {
          bool is_town = false;
          if (uShowTowns) {
            is_town = (texture2D(uTownsSampler, vTextureCoord) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s + 0.0005, vTextureCoord.t)) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s, vTextureCoord.t + 0.0005)) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s + 0.0005, vTextureCoord.t + 0.0005)) != vec4(0.0, 0.0, 0.0, 0.0));
          }
          if (is_town)
            gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
          else {
            if (uShowBg) {
              gl_FragColor = texture2D(uMapSampler, vec2(vTextureCoord.s, vTextureCoord.t));
              if (uGreyBg) {
                float grey = (0.34 * gl_FragColor.r + 0.5 * gl_FragColor.g + 0.16 * gl_FragColor.b);
                gl_FragColor = vec4(grey, grey, grey, gl_FragColor[3]);
              }
            }
            if (uShowOverlay) {
              vec4 col = texture2D(uOverlaySampler, vTextureCoord);
              if (uShowBg) gl_FragColor = 0.5 * gl_FragColor + 0.5 * col;
              else gl_FragColor = col;
            }
          }
        }
      }
    </script>

    <script id="gauss-fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D uTownsSampler;
      uniform sampler2D uOvr0Sampler;
      uniform sampler2D uOvr1Sampler;
      uniform float uKernel[300];
      uniform int uKernelSize;
      uniform int uRace;
      uniform int uPass;
      uniform float uMaxValue;

      varying vec2 vTextureCoord;

      // http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm
      uniform float uGamma;

      vec4 val2rgb(float val, float max_val) {
        vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
        float factor = 0.0, r = 0.0, g = 0.0, b = 0.0;
        float wavelen = 380.0 + 400.0 * val / max_val;
        if (wavelen < 440.0) { r = -(wavelen - 440.0) / 60.0; b = 1.0; }
        else if (wavelen < 490.0) { g = (wavelen - 440.0) / 50.0; b = 1.0; }
        else if (wavelen < 510.0) { g = 1.0; b = -(wavelen - 510.0) / 20.0; }
        else if (wavelen < 580.0) { r = (wavelen - 510.0) / 70.0; g = 1.0; }
        else if (wavelen < 645.0) { r = 1.0; g = -(wavelen - 645.0) / 65.0; }
        else if (wavelen < 780.0) r = 1.0;
        if (wavelen < 420.0) factor = 0.3 + 0.7 * (wavelen - 380.0) / 40.0;
        else if (wavelen < 700.0) factor = 1.0;
        else if (wavelen < 780.0) factor = 0.3 + 0.7 * (780.0 - wavelen) / 80.0;
        if (r > 0.0) color.r = pow(r * factor, uGamma);
        if (g > 0.0) color.g = pow(g * factor, uGamma);
        if (b > 0.0) color.b = pow(b * factor, uGamma);
        return color;
      }

      float half2float(vec2 c) {
        float b0 = c.s * 255.0;
        float b1 = c.t * 255.0;
        float s = (floor(b0 / 128.0) == 0.0 ? 1.0 : -1.0);
        if (s == -1.0) b0 -= 128.0;
        float e = floor(b0 / 4.0);
        b0 -= e * 4.0;
        float m = b0 * 256.0 + b1;
        if (e > 0.0 && e < 31.0)
          return s * pow(2.0, e - 15.0) * (1.0 + m / 1024.0);
        else if (e == 0.0 && m == 0.0)
          return 0.0;
        else if (e == 0.0 && m != 0.0)
          return s * 6.1035 * (m / 1024.0) * 0.00001;
        else if (e == 31.0 && m == 0.0)
          return s * 65504.0; //INF (65504 is max representable value)
        return 0.0; //NaN
      }

      vec2 float2half(float c) {
        float s = 0.0;
        if (c < 0.0) {
          s = 1.0;
          c *= -1.0;
        }
        if (c > 65504.0) return (s == 0.0 ? vec2(124.0 / 255.0, 0.0) : vec2(252.0 / 255.0, 0.0)); //INF
        if (c == 0.0) return vec2(0.0, 0.0);
        float m, e, ve;
        if (c < 0.0000610352) { // subnormal; 0.0000610352 = 2^-14
          e = 0.0;
          m = c * 16777216.0;   // 16777216.0 = 2^24
        }
        else {                  //normal
          for (float i=-14.0; i<=15.0; i++) {
            ve = pow(2.0, i);
            m = c / ve;
            if (m < 2.0 && m >= 1.0) {
              e = i + 15.0;
              m = (m - 1.0) * 1024.0;
              break;
            }
          }
        }
        float m0 = floor(m / 256.0);
        float m1 = floor(m - m0 * 256.0);
        return vec2((s * 128.0 + e * 4.0 + m0) / 255.0, m1 / 255.0);
      }

      float getSampleHoriz(vec2 coord) {
        if (coord.s < 0.0 || coord.s > 1.0) return 0.0;
        vec4 sample = texture2D(uTownsSampler, coord);
        if (uRace == -1 || uRace == int(sample.a * 256.0))
          return half2float(sample.rg);
        return 0.0;
      }

      vec2 apply_kernel(vec2 coord) {
        float sum = 0.0;
        for (int i = 0; i < 300; i++) {
          if (i == uKernelSize) break;
          float delta = 0.001 * (float(i) - floor(float(uKernelSize) / 2.0));
          if (uPass == 0) {
            sum += uKernel[i] * getSampleHoriz(vec2(coord.s + delta, coord.t));
            sum += uKernel[i] * getSampleHoriz(vec2(coord.s + 0.0005 + delta, coord.t));
            sum += uKernel[i] * getSampleHoriz(vec2(coord.s + delta, coord.t + 0.0005));
            sum += uKernel[i] * getSampleHoriz(vec2(coord.s + 0.0005 + delta, coord.t + 0.0005));
          }
          else {
            vec2 pos = vec2(coord.s, coord.t + delta);
            if (pos.t >= 0.0 && pos.t <= 1.0)
              sum += uKernel[i] * half2float(texture2D(uOvr0Sampler, pos).rg);
          }
        }
        return float2half(sum);
      }

      void main(void) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        if (uPass == 0 || uPass == 1) {
          vec2 sum = apply_kernel(vTextureCoord);
          gl_FragColor = vec4(sum.r, sum.g, 0.0, 1.0);
        }
        else if (uPass == 2) {
          float max_val = 0.0;
          for (int i = 0; i < 10; i++)
            for (int j = 0; j < 10; j++) {
              float val = half2float(texture2D(uOvr1Sampler, vTextureCoord + vec2(float(i) * 0.001, float(j) * 0.001)).rg);
              if (val > max_val) max_val = val;
            }
          vec2 max_val_half = float2half(max_val);
          gl_FragColor = vec4(max_val_half.r, max_val_half.g, 0.0, 1.0);
        }
        else if (uPass == 3) {
          gl_FragColor = val2rgb(half2float(texture2D(uOvr1Sampler, vTextureCoord).rg), uMaxValue);
        }
      }
    </script>

    <script id="partition-fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D uTownsSampler;
      uniform sampler2D uIdxSampler;
      uniform sampler2D uTempSampler;
      uniform float uKernel[300];
      uniform int uKernelSize;
      uniform int uPass;
      uniform int uPartMode;

      varying vec2 vTextureCoord;

      float half2float(vec2 c) {
        float b0 = c.s * 255.0;
        float b1 = c.t * 255.0;
        float s = (floor(b0 / 128.0) == 0.0 ? 1.0 : -1.0);
        if (s == -1.0) b0 -= 128.0;
        float e = floor(b0 / 4.0);
        b0 -= e * 4.0;
        float m = b0 * 256.0 + b1;
        if (e > 0.0 && e < 31.0)
          return s * pow(2.0, e - 15.0) * (1.0 + m / 1024.0);
        else if (e == 0.0 && m == 0.0)
          return 0.0;
        else if (e == 0.0 && m != 0.0)
          return s * 6.1035 * (m / 1024.0) * 0.00001;
        else if (e == 31.0 && m == 0.0)
          return s * 65504.0; //INF (65504 is max representable value)
        return 0.0; //NaN
      }

      vec2 float2half(float c) {
        float s = 0.0;
        if (c < 0.0) {
          s = 1.0;
          c *= -1.0;
        }
        if (c > 65504.0) return (s == 0.0 ? vec2(124.0 / 255.0, 0.0) : vec2(252.0 / 255.0, 0.0)); //INF
        if (c == 0.0) return vec2(0.0, 0.0);
        float m, e, ve;
        if (c < 0.0000610352) { // subnormal; 0.0000610352 = 2^-14
          e = 0.0;
          m = c * 16777216.0;   // 16777216.0 = 2^24
        }
        else {                  //normal
          for (float i=-14.0; i<=15.0; i++) {
            ve = pow(2.0, i);
            m = c / ve;
            if (m < 2.0 && m >= 1.0) {
              e = i + 15.0;
              m = (m - 1.0) * 1024.0;
              break;
            }
          }
        }
        float m0 = floor(m / 256.0);
        float m1 = floor(m - m0 * 256.0);
        return vec2((s * 128.0 + e * 4.0 + m0) / 255.0, m1 / 255.0);
      }

      float apply_kernel(vec2 coord, int tile_idx) {
        float sum = 0.0;
        float pid = -1.0;
        float pids[36];
        for (int i=0; i<36; i++) pids[i] = -1.0;
        for (int i=0; i<300; i++) {
          if (i == uKernelSize) break;
          float delta = 0.001 * (float(i) - floor(float(uKernelSize) / 2.0));
          for (float dx=0.0; dx<=0.0005; dx+=0.0005)
            for (float dy=0.0; dy<=0.0005; dy+=0.0005) {
              vec2 map_pos = vec2(coord.x + delta + dx, coord.y + dy);
              if (map_pos.x >= 0.0 && map_pos.x <= 1.0) {
                vec4 sample = texture2D(uTownsSampler, map_pos);
                float s_pid = (uPartMode == 0 ? sample.a : sample.b);
                for (int k=0; k<36; k++)
                  if (pids[k] == s_pid || pids[k] == -1.0) {
                    pids[k] = s_pid;
                    if (k == tile_idx) {
                      if (uPass == 0) pid = s_pid;
                      else if (uPass == 1) sum += uKernel[i] * half2float(sample.rg);
                    }
                    break;
                  }
              }
            }
        }
        if (uPass == 0) return pid;
        else return sum;
      }

      const float idx_px = 1.0 / (6.0 * 500.0);
      const float dd = 1.0 / (6.0 * 1000.0);

      float load_val(vec2 coord) {
        vec4 val_sample = texture2D(uTempSampler, coord);
        int comp = int(floor(mod(coord.y, idx_px) / dd));
        if (comp == 0) return half2float(val_sample.rg);
        else if (comp == 1) return half2float(val_sample.ba);
        return 0.0;
      }

      float load_pid(vec2 coord) {
        vec4 pid_sample = texture2D(uIdxSampler, coord);
        int comp = int(2.0 * floor(mod(coord.y, idx_px) / dd) + floor(mod(coord.x, idx_px) / dd));
        if (comp == 0) return pid_sample.r;
        else if (comp == 1) return pid_sample.g;
        else if (comp == 2) return pid_sample.b;
        else if (comp == 3) return pid_sample.a;
        return -1.0;
      }

      void main(void) {
        if (uPass == 0 || uPass == 1) {
          vec2 tile = vec2(floor(vTextureCoord.x * 6.0), floor(vTextureCoord.y * 6.0));
          int tile_idx = 6 * int(tile.y) + int(tile.x);
          vec2 coord = 6.0 * vTextureCoord - tile;
          if (uPass == 0) {
            gl_FragColor.r = apply_kernel(coord, tile_idx);
            gl_FragColor.g = apply_kernel(vec2(coord.x + 0.001, coord.y), tile_idx);
            gl_FragColor.b = apply_kernel(vec2(coord.x, coord.y + 0.001), tile_idx);
            gl_FragColor.a = apply_kernel(vec2(coord.x + 0.001, coord.y + 0.001), tile_idx);
          }
          else if (uPass == 1) {
            gl_FragColor.rg = float2half(apply_kernel(coord, tile_idx));
            gl_FragColor.ba = float2half(apply_kernel(vec2(coord.x, coord.y + 0.001), tile_idx));
          }
        }
        else if (uPass == 2) {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
          float sums[36];
          float pids[36];
          //init pids
          for (int i=0; i<36; i++) pids[i] = -1.0;
          for (int tile_idx=0; tile_idx<36; tile_idx++) {
            int tile_x = int(mod(float(tile_idx), 6.0));
            int tile_y = int(float(tile_idx - tile_x) / 6.0);
            vec2 coord = vec2((float(tile_x) + vTextureCoord.x) / 6.0, (float(tile_y) + vTextureCoord.y) / 6.0);
            pids[tile_idx] = load_pid(coord);
            if (pids[tile_idx] == -1.0) break;
          }
          for (int tile_idx=0; tile_idx<36; tile_idx++) {
            int tile_x = int(mod(float(tile_idx), 6.0));
            int tile_y = int(float(tile_idx - tile_x) / 6.0);
            vec2 coord = vec2((float(tile_x) + vTextureCoord.x) / 6.0, (float(tile_y) + vTextureCoord.y) / 6.0);
            for (int i=0; i<300; i++) {
              if (i == uKernelSize) break;
              float delta = dd * (float(i) - floor(float(uKernelSize) / 2.0));
              vec2 pos = vec2(coord.s, coord.t + delta);
              if (pos.t >= 0.0 && pos.t <= 1.0) {
                float pid = load_pid(pos);
                for (int k=0; k<36; k++)
                  if (pids[k] == pid || pids[k] == -1.0) {
                    pids[k] = pid;
                    break;
                  }
              }
            }
          }
          //compute sums
          for (int i=0; i<36; i++) sums[i] = 0.0;
          for (int tile_idx=0; tile_idx<36; tile_idx++) {
            int tile_x = int(mod(float(tile_idx), 6.0));
            int tile_y = int(float(tile_idx - tile_x) / 6.0);
            vec2 coord = vec2((float(tile_x) + vTextureCoord.x) / 6.0, (float(tile_y) + vTextureCoord.y) / 6.0);
            for (int i=0; i<300; i++) {
              if (i == uKernelSize) break;
              float delta = dd * (float(i) - floor(float(uKernelSize) / 2.0));
              vec2 pos = vec2(coord.s, coord.t + delta);
              if (pos.t >= 0.0 && pos.t <= 1.0) {
                float pid = load_pid(pos);
                for (int k=0; k<36; k++)
                  if (pids[k] == pid) {
                    sums[k] += load_val(pos);
                    break;
                  }
              }
            }
          }
          //find max
          float max_sum = 0.0;
          float max_pid = -1.0;
          for (int i=0; i<36; i++)
            if (sums[i] > max_sum) {
              max_sum = sums[i];
              max_pid = pids[i];
            }
          //dispaly
          //if (max_pid == 1.0 / 255.0) gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
          //else gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
          gl_FragColor = vec4(0.0, max_pid, 0.0, 1.0);
        }
      }
    </script>

    <script id="main_shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying vec2 vTextureCoord;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
      }
    </script>
    <title>Illymap - Illyriad Heat Map</title>
  </head>

  <body>
    <div class="outer">
      <header class="inner">
        <div id="header_left">
          <h1>Illymap</h1>
          <h2><a href="http://www.illyriad.co.uk/" target="_blank">Illyriad</a> Heat &amp; Partition Maps</h2>
        </div>
        <div id="header_right">
          <form name="ui_form">
            <div class="ui_panel">
              <div id="server_info" class="tooltip" data-tooltip="Double-click on the map to open a new tab with the Illyriad map page centered on the position.">server:?<br/>date:?<br/></div>
            </div>
            <div class="ui_panel">
              <label id="overlay_mode_label" for="overlay_mode" class="tooltip" data-tooltip="Select the map overlay mode. Alliance partition is the heaviest computation, and it will eat memory proportional to the maximum number of alliances that have influence over a single spot. To decrease that chance, use a smaller sigma.">Overlay:</label>
              <select id="overlay_mode">
                <option value="none" selected="selected">None</option>
                <option value="pop">Population</option>
                <option value="pop:E">Elves</option>
                <option value="pop:H">Humans</option>
                <option value="pop:D">Dwarves</option>
                <option value="pop:O">Orcs</option>
                <option value="par:races">Races (Partition)</option>
                <option value="par:alliances">Alliances (Partition)</option>
                <option value="par:confeds">Confederations (Partition)</option>
              </select><br />
              <label id="std_dev_label" for="std_dev" class="tooltip" data-tooltip="The population of each city is spread out according to a normal (Gaussian) distribution. With this option you can change its standard deviation. Higher values will give a smoother appearence to the overlays. Units are map-units, and the map is 1:2 vs. in-game squares.">Sigma:</label>
              <select id="std_dev">
                <option value="2">2</option>
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15" selected="selected">15</option>
                <option value="20">20</option>
                <option value="30">30</option>
                <option value="50">50</option>
              </select><br />
              <label id="gamma_label" for="gamma" class="tooltip" data-tooltip="Gamma factor for the false color overlays. Smaller values will create sharper color boundaries.">Gamma:</label>
              <select id="gamma">
                <option value="0.1">0.1</option>
                <option value="0.2">0.2</option>
                <option value="0.3">0.3</option>
                <option value="0.4">0.4</option>
                <option value="0.5">0.5</option>
                <option value="0.6">0.6</option>
                <option value="0.7">0.7</option>
                <option value="0.8" selected="selected">0.8</option>
                <option value="0.9">0.9</option>
                <option value="1.0">1.0</option>
              </select>
            </div>
            <div class="ui_panel">
              <input id="show_map" type="checkbox" checked="checked" /> <label for="show_map" class="tooltip" data-tooltip="Show the background map.">Show Map</label><br />
              <input id="show_towns" type="checkbox" /> <label for="show_towns" class="tooltip" data-tooltip="Show towns as blue dots on the map.">Show Towns</label><br />
              <input id="show_capitals" type="checkbox" checked="checked" /> <label for="show_capitals" class="tooltip" data-tooltip="Show alliance capitals as yellow stars. Mouse over them to see more information.">Show Capitals</label>
            </div>
            <div class="ui_panel" style="display: none"><a id="xml2json_btn" href="#" class="tooltip" data-tooltip="For hosters. This is a static app, and can work locally on a computer (copy all files). To update the dataset: After uploading newer versions of datafile_alliances.xml and datafile_towns.xml into the data folder, click this to generate the json data. After generation, copy the data from the screen and paste it into the data/data.json file.">XML2JSON</a></div>
          </form>
        </div>
      </header>
    </div>

    <div class="outer">
      <section id="main_content" class="inner">
        <canvas id="map" width="1000" height="1000"></canvas>
        <div id="pos_info">[ 0 : 0 ]</div>
        <div id="jsondiv"></div>
        <div id="infobox"></div>
      </section>
    </div>

    <div class="outer">
      <footer class="inner">
        <p>&copy; 2012 by The Interwebs</p>
        <p><a href="https://github.com/clnx/illymap" target="_blank">Project</a> hosted on GitHub</p>
        <br />
      </footer>
    </div>
  </body>
</html>
