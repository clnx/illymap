<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <meta name="description" content="Illymap : Illyriad Map Smelter" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <script type="text/javascript" src="javascripts/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="javascripts/gl-matrix-1.3.5-min.js"></script>
    <script type="text/javascript" src="javascripts/main.js"></script>
    <script id="main_shader-fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D uMapSampler;
      uniform sampler2D uStarSampler;
      uniform sampler2D uTownsSampler;
      uniform sampler2D uOverlaySampler;

      uniform bool uGreyBg;
      uniform bool uStars;
      uniform vec3 uStarColor;
      uniform bool uShowTowns;
      uniform bool uShowBg;
      uniform bool uShowOverlay;

      varying vec2 vTextureCoord;

      void main(void) {
        if (uStars) {
          vec4 textureColor = texture2D(uStarSampler, vec2(vTextureCoord.s, vTextureCoord.t));
          gl_FragColor = textureColor * vec4(uStarColor, 1.0);
        }
        else {
          bool is_town = false;
          if (uShowTowns) {
            is_town = (texture2D(uTownsSampler, vTextureCoord) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s + 0.0005, vTextureCoord.t)) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s, vTextureCoord.t + 0.0005)) != vec4(0.0, 0.0, 0.0, 0.0));
            if (!is_town) is_town = (texture2D(uTownsSampler, vec2(vTextureCoord.s + 0.0005, vTextureCoord.t + 0.0005)) != vec4(0.0, 0.0, 0.0, 0.0));
          }
          if (is_town)
            gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
          else {
            if (uShowBg) {
              gl_FragColor = texture2D(uMapSampler, vec2(vTextureCoord.s, vTextureCoord.t));
              if (uGreyBg) {
                float grey = (0.34 * gl_FragColor.r + 0.5 * gl_FragColor.g + 0.16 * gl_FragColor.b);
                gl_FragColor = vec4(grey, grey, grey, gl_FragColor[3]);
              }
            }
            if (uShowOverlay) {
              vec4 col = texture2D(uOverlaySampler, vTextureCoord);
              if (uShowBg) gl_FragColor = 0.5 * gl_FragColor + 0.5 * col;
              else gl_FragColor = col;
            }
          }
        }
      }
    </script>

    <script id="gauss-fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D uTownsSampler;
      uniform sampler2D uOvr0Sampler;
      uniform sampler2D uOvr1Sampler;
      uniform sampler2D uOvr2Sampler;
      uniform float uKernel[300];
      uniform int uKernelSize;
      uniform vec2 uFilter;
      uniform int uActiveSampler;
      uniform int uPass;
      uniform float uMaxValue;
      uniform vec3 uColors[15];
      uniform float uSelPar;

      varying vec2 vTextureCoord;

      // http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm
      uniform float uGamma;

      vec4 val2rgb(float val, float max_val) {
        vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
        float factor = 0.0, r = 0.0, g = 0.0, b = 0.0;
        float wavelen = 380.0 + 400.0 * val / max_val;
        if (wavelen < 440.0) { r = -(wavelen - 440.0) / 60.0; b = 1.0; }
        else if (wavelen < 490.0) { g = (wavelen - 440.0) / 50.0; b = 1.0; }
        else if (wavelen < 510.0) { g = 1.0; b = -(wavelen - 510.0) / 20.0; }
        else if (wavelen < 580.0) { r = (wavelen - 510.0) / 70.0; g = 1.0; }
        else if (wavelen < 645.0) { r = 1.0; g = -(wavelen - 645.0) / 65.0; }
        else if (wavelen < 780.0) r = 1.0;
        if (wavelen < 420.0) factor = 0.3 + 0.7 * (wavelen - 380.0) / 40.0;
        else if (wavelen < 700.0) factor = 1.0;
        else if (wavelen < 780.0) factor = 0.3 + 0.7 * (780.0 - wavelen) / 80.0;
        if (r > 0.0) color.r = pow(r * factor, uGamma);
        if (g > 0.0) color.g = pow(g * factor, uGamma);
        if (b > 0.0) color.b = pow(b * factor, uGamma);
        return color;
      }

      float half2float(vec2 c) {
        float b0 = c.s * 255.0;
        float b1 = c.t * 255.0;
        float s = (floor(b0 / 128.0) == 0.0 ? 1.0 : -1.0);
        if (s == -1.0) b0 -= 128.0;
        float e = floor(b0 / 4.0);
        b0 -= e * 4.0;
        float m = b0 * 256.0 + b1;
        if (e > 0.0 && e < 31.0)
          return s * pow(2.0, e - 15.0) * (1.0 + m / 1024.0);
        else if (e == 0.0 && m == 0.0)
          return 0.0;
        else if (e == 0.0 && m != 0.0)
          return s * 6.1035 * (m / 1024.0) * 0.00001;
        else if (e == 31.0 && m == 0.0)
          return s * 65504.0; //INF (65504 is max representable value)
        return 0.0; //NaN
      }

      vec2 float2half(float c) {
        float s = 0.0;
        if (c < 0.0) {
          s = 1.0;
          c *= -1.0;
        }
        if (c > 65504.0) return (s == 0.0 ? vec2(124.0 / 255.0, 0.0) : vec2(252.0 / 255.0, 0.0)); //INF
        if (c == 0.0) return vec2(0.0, 0.0);
        float m, e, ve;
        if (c < 0.0000610352) { // subnormal; 0.0000610352 = 2^-14
          e = 0.0;
          m = c * 16777216.0;   // 16777216.0 = 2^24
        }
        else {                  //normal
          for (float i=-14.0; i<=15.0; i++) {
            ve = pow(2.0, i);
            m = c / ve;
            if (m < 2.0 && m >= 1.0) {
              e = i + 15.0;
              m = (m - 1.0) * 1024.0;
              break;
            }
          }
        }
        float m0 = floor(m / 256.0);
        float m1 = floor(m - m0 * 256.0);
        return vec2((s * 128.0 + e * 4.0 + m0) / 255.0, m1 / 255.0);
      }

      void apply_sample(vec2 coord, float k_val, inout float sum) {
        if (coord.s < 0.0 || coord.s > 1.0) return;
        vec4 sample = texture2D(uTownsSampler, coord);
        if ((uFilter.x == 0.0 || uFilter.x == sample.b) && (uFilter.y == 0.0 || uFilter.y == sample.a))
          sum += k_val * half2float(sample.rg);
      }

      const float min_pop = 0.5;

      vec4 apply_kernel(vec2 coord) {
        float sum = 0.0;
        for (int i = 0; i < 300; i++) {
          if (i == uKernelSize) break;
          float delta = 0.001 * (float(i) - floor(float(uKernelSize) / 2.0));
          if (uPass == 0) {
            apply_sample(vec2(coord.s + delta, coord.t), uKernel[i], sum);
            apply_sample(vec2(coord.s + 0.0005 + delta, coord.t), uKernel[i], sum);
            apply_sample(vec2(coord.s + delta, coord.t + 0.0005), uKernel[i], sum);
            apply_sample(vec2(coord.s + 0.0005 + delta, coord.t + 0.0005), uKernel[i], sum);
          }
          else if (uPass == 1) {
            vec2 pos = vec2(coord.s, coord.t + delta);
            if (pos.t >= 0.0 && pos.t <= 1.0)
              sum += uKernel[i] * half2float(texture2D(uOvr0Sampler, pos).rg);
          }
        }
        vec2 pid = uFilter;
        if (uPass == 1 && uActiveSampler > 0) {
          vec4 sample = (uActiveSampler == 1 ? texture2D(uOvr1Sampler, coord) : texture2D(uOvr2Sampler, coord));
          float sum_p = half2float(sample.rg);
          if (sum_p > sum && sum_p > min_pop) {
            sum = sum_p;
            pid = sample.ba;
          }
          else if (sum <= min_pop) pid = vec2(0.0);
        }
        vec2 sum_h = float2half(sum);
        return vec4(sum_h.x, sum_h.y, pid.x, pid.y);
      }

      bool proc_tex(vec2 coord, int tex_idx) {
        if (tex_idx == 0) return false;
        --tex_idx;
        int size = tex_idx / 5;
        int mode = tex_idx - 5 * size;
        size = 4 * (size + 2);
        int x = int(coord.x * 1000.0);
        int y = int(coord.y * 1000.0);
        int d1 = y - x, d2 = x + y;
        int rx = x - size * (x / size);
        int ry = y - size * (y / size);
        if (mode == 3) return rx == 0;
        else if (mode == 4) return ry == 0;
        else if (mode == 0) return d1 - size * (d1 / size) == 0;
        else if (mode == 1) return d2 - size * (d2 / size) == 0;
        else if (mode == 2) return rx == 0 && ry == 0 || rx == 1 && ry == 0 ||
          rx == 2 && ry == 0 || rx == 1 && ry == 1 || rx == 1 && ry == size - 1;
      }

      void main(void) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        if (uPass == 0 || uPass == 1) {
          gl_FragColor = apply_kernel(vTextureCoord);
        }
        else if (uPass == 2) {
          float max_val = 0.0;
          for (int i = 0; i < 10; i++)
            for (int j = 0; j < 10; j++) {
              vec2 pos = vTextureCoord + vec2(float(i) * 0.001, float(j) * 0.001);
              float val = half2float(uActiveSampler == 1 ? texture2D(uOvr1Sampler, pos).rg : texture2D(uOvr2Sampler, pos).rg);
              if (val > max_val) max_val = val;
            }
          vec2 max_val_half = float2half(max_val);
          gl_FragColor = vec4(max_val_half.r, max_val_half.g, 0.0, 1.0);
        }
        else if (uPass == 3) {
          gl_FragColor = val2rgb(half2float(uActiveSampler == 1 ? texture2D(uOvr1Sampler, vTextureCoord).rg : texture2D(uOvr2Sampler, vTextureCoord).rg), uMaxValue);
        }
        else if (uPass == 4) {
          vec4 sample = (uActiveSampler == 1 ? texture2D(uOvr1Sampler, vTextureCoord) : texture2D(uOvr2Sampler, vTextureCoord));
          float pid = (sample.b > 0.0 ? sample.b : sample.a);
          if (pid == 0.0) return;
          bool races = (sample.a > 0.0);
          int id = int(pid * 255.0) - 1;
          bool selected = (uSelPar > 0.0 && uSelPar == pid);
          int tex_idx = id / 15;
          int col_idx = id - 15 * tex_idx;
          vec3 color = vec3(0.0);
          for (int i=0; i<15; i++) {
            color = uColors[i];
            if (i == col_idx) break;
          }
          if (selected) {
            if (!races) color = vec3(0.0);
            if (proc_tex(vTextureCoord, tex_idx > 0 ? tex_idx : 3))
              color = vec3(1.0);
          }
          else {
            if (proc_tex(vTextureCoord, tex_idx))
              color = vec3(0.0);
          }
          gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
        }
      }
    </script>

    <script id="main_shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying vec2 vTextureCoord;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
      }
    </script>
    <title>Illymap - Illyriad Heat Map</title>
  </head>

  <body>
    <div class="outer">
      <header class="inner">
        <div id="header_left">
          <h1>Illymap</h1>
          <h2><a href="http://www.illyriad.co.uk/" target="_blank">Illyriad</a> Heat &amp; Partition Maps</h2>
        </div>
        <div id="header_right">
          <form name="ui_form">
            <div class="ui_panel">
              <div id="server_info" class="tooltip" data-tooltip="Double-click on the map to open a new tab with the Illyriad map page centered on the position.">server:?<br/>date:?<br/></div>
            </div>
            <div class="ui_panel">
              <label id="overlay_mode_label" for="overlay_mode" class="tooltip" data-tooltip="Select the map overlay mode. Heat maps should be completed instantly. Alliance/Confed partition is the heaviest GPU computation, with time ~ sigma. At sigma = 15 it can take ~4 sec on a HD7950 during which your screen may freeze. Don't worry ;)">Overlay:</label>
              <select id="overlay_mode">
                <option value="none" selected="selected">None</option>
                <option value="pop">Population</option>
                <option value="pop:E">Elves</option>
                <option value="pop:H">Humans</option>
                <option value="pop:D">Dwarves</option>
                <option value="pop:O">Orcs</option>
                <option value="par:races">Races (Partition)</option>
                <option value="par:alliances">Alliances (Partition)</option>
                <option value="par:confeds">Confederations (Partition)</option>
              </select><br />
              <label id="std_dev_label" for="std_dev" class="tooltip" data-tooltip="The population of each city is spread out according to a normal (Gaussian) distribution. With this option you can change its standard deviation. Higher values will give a smoother appearence to the overlays. Units are map-units, but the map is 1:2 vs. in-game squares.">Sigma:</label>
              <select id="std_dev">
                <option value="2">2</option>
                <option value="5">5</option>
                <option value="10">10</option>
                <option value="15" selected="selected">15</option>
                <option value="20">20</option>
                <option value="30">30</option>
                <option value="50">50</option>
              </select><br />
              <label id="gamma_label" for="gamma" class="tooltip" data-tooltip="Gamma factor for the false color overlays (heat maps). Smaller values will create sharper color boundaries.">Gamma:</label>
              <select id="gamma">
                <option value="0.1">0.1</option>
                <option value="0.2">0.2</option>
                <option value="0.3">0.3</option>
                <option value="0.4">0.4</option>
                <option value="0.5">0.5</option>
                <option value="0.6">0.6</option>
                <option value="0.7">0.7</option>
                <option value="0.8" selected="selected">0.8</option>
                <option value="0.9">0.9</option>
                <option value="1.0">1.0</option>
              </select>
            </div>
            <div class="ui_panel">
              <input id="show_map" type="checkbox" checked="checked" /> <label for="show_map" class="tooltip" data-tooltip="Show the background map.">Show Map</label><br />
              <input id="show_towns" type="checkbox" /> <label for="show_towns" class="tooltip" data-tooltip="Show towns as blue dots on the map.">Show Towns</label><br />
              <input id="show_capitals" type="checkbox" checked="checked" /> <label for="show_capitals" class="tooltip" data-tooltip="Show alliance capitals as yellow stars. Mouse over them to see more information.">Show Capitals</label>
            </div>
            <div class="ui_panel" style="display: none"><a id="xml2json_btn" href="#" class="tooltip" data-tooltip="For hosters. This is a static app, and can work locally on a computer (copy all files). To update the dataset: After uploading newer versions of datafile_alliances.xml and datafile_towns.xml into the data folder, click this to generate the json data. After generation, copy the data from the screen and paste it into the data/data.json file.">XML2JSON</a></div>
          </form>
        </div>
      </header>
    </div>

    <div class="outer">
      <section id="main_content" class="inner">
        <canvas id="map" width="1000" height="1000"></canvas>
        <div id="pos_info">[ 0 : 0 ]</div>
        <div id="jsondiv"></div>
        <div id="infobox"></div>
      </section>
    </div>

    <div class="outer">
      <footer class="inner">
        <p>&copy; 2012 by The Interwebs</p>
        <p><a href="https://github.com/clnx/illymap" target="_blank">Project</a> hosted on GitHub</p>
        <br />
      </footer>
    </div>
  </body>
</html>
